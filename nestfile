db:
    env: DOCKER_CMD="docker compose --env-file .env -p substrack -f docker/compose.yml -f docker/infra.yml exec backend"
    desc: Database commands
    env: .env
    env: TZ=UTC+7

    backup(!backup_path|p: str = "./backups"):
        var filename = $(date -u +"%d-%m-%Y__%H:%M"a)_$POSTGRES_DB.dump.gz
        desc: Backup via temporary container (Gzipped custom format)
        before: mkdir -p "{{backup_path}}" && echo "ðŸ”„ Backing up to {{backup_path}}/{{filename}} (compressed)"
        script: |
            docker run --rm -i --network substrack-network -e PGPASSWORD="$POSTGRES_PASSWORD" \
              postgres:15-alpine pg_dump -h $POSTGRES_HOST -U "$POSTGRES_USER" -d "$POSTGRES_DB" -Fc | gzip > "{{backup_path}}/{{filename}}"
        after: echo "âœ… Backed up to {{backup_path}}/{{filename}}"

    restore(backup_file: str):
        desc: Restore database (auto-detects .dump, .sql, .gz)
        before: echo "ðŸ”„ Restoring database $POSTGRES_DB ..."
        after: echo "âœ… Restored database $POSTGRES_DB"
        script: |
            if [ -z "{{backup_file}}" ]; then
                echo "âŒ Please specify a backup file."
                exit 1
            fi

            if [ ! -f "{{backup_file}}" ]; then
                echo "âŒ File not found: {{backup_file}}"
                exit 1
            fi

            echo "ðŸ“¦ Restoring from: {{backup_file}}"

            # Helper to get stream (decompressed if needed)
            get_stream() {
                case "$1" in
                    *.gz) gunzip -c "$1" ;;
                    *) cat "$1" ;;
                esac
            }

            # Step 0: Ensure role exists
            docker run --rm -i --network substrack-network -e PGPASSWORD="$POSTGRES_PASSWORD" postgres:15-alpine \
              psql -h $POSTGRES_HOST -U "$POSTGRES_USER" -d "postgres" \
              -c "DO \$\$ BEGIN IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'yourtask') THEN CREATE ROLE yourtask; END IF; END \$\$;" 2>/dev/null || true

            # Step 1: Terminate connections
            docker run --rm -i --network substrack-network -e PGPASSWORD="$POSTGRES_PASSWORD" postgres:15-alpine \
              psql -h $POSTGRES_HOST -U "$POSTGRES_USER" -d "postgres" \
              -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$POSTGRES_DB' AND pid <> pg_backend_pid();" || true

            # Step 2: Detect format and restore
            # We peek at the stream to detect format
            if get_stream "{{backup_file}}" | head -c 5 | grep -q "PGDMP"; then
                echo "ðŸ“¦ Detected binary dump format. Using pg_restore..."
                get_stream "{{backup_file}}" | docker run --rm -i --network substrack-network -e PGPASSWORD="$POSTGRES_PASSWORD" postgres:15-alpine \
                    pg_restore -h $POSTGRES_HOST -U "$POSTGRES_USER" -d "$POSTGRES_DB" \
                    --clean --if-exists --no-owner --no-privileges
            else
                echo "ðŸ“„ Detected plain SQL format. Using psql..."
                docker run --rm -i --network substrack-network -e PGPASSWORD="$POSTGRES_PASSWORD" postgres:15-alpine \
                    psql -h $POSTGRES_HOST -U "$POSTGRES_USER" -d "$POSTGRES_DB" \
                    -c "DO \$\$ DECLARE r RECORD; BEGIN FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE'; END LOOP; FOR r IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP EXECUTE 'DROP SEQUENCE IF EXISTS ' || quote_ident(r.sequence_name) || ' CASCADE'; END LOOP; FOR r IN (SELECT viewname FROM pg_views WHERE schemaname = 'public') LOOP EXECUTE 'DROP VIEW IF EXISTS ' || quote_ident(r.viewname) || ' CASCADE'; END LOOP; END \$\$;"
                get_stream "{{backup_file}}" | docker run --rm -i --network substrack-network -e PGPASSWORD="$POSTGRES_PASSWORD" postgres:15-alpine \
                    psql -h $POSTGRES_HOST -U "$POSTGRES_USER" -d "$POSTGRES_DB" --set ON_ERROR_STOP=off || true
            fi

    aerich(*):
        desc: Aerich
        script: $DOCKER_CMD uv run aerich {{*}}

app:
    env: DOCKER_CMD="docker compose --env-file .env -p substrack -f docker/compose.yml "
    desc: Control Application

    logs(*):
        desc: Logs Application
        script: |
            $DOCKER_CMD logs {{*}}

    run(!build: bool = true, !include: arr = [], type: str = "dev"):
        desc: Run Application with build option
        env: .env
        script: |
            if [ "{{type}}" == "dev" ]; then
                $DOCKER_CMD -f docker/{{type}}.yml up {{include}} -d {{build|copy}} --force-recreate
            elif [ "{{type}}" == "prod" ]; then
                $DOCKER_CMD up {{include}} -d {{build|copy}} --force-recreate
            fi

    down:
        desc: Down Services
        script: |
            $DOCKER_CMD down 

    exec(app: str, *commands):
        desc: Execute commands in Container
        script: | 
            $DOCKER_CMD exec {{app}} {{*commands}} 
