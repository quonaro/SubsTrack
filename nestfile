db:
    > desc: Database commands
    
    backup(!backup_path|p: str = "./backups", !host|H: str = $DB_HOST):
        @var filename = $(date -u +"%d-%m-%Y__%H:%M")_$DB_NAME.sql
        > env: .env 
        > env: PGPASSWORD=$DB_PASSWORD
        > desc: Backup database
        > before: echo "ðŸ”„ Backuping database $DB_NAME to {{backup_path}}/{{filename}}"
        > after: echo "âœ… Backuped database $DB_NAME to {{backup_path}}/{{filename}}"
        > script: |
            pg_dump -U $DB_USER -h {{host}} -p $DB_PORT -d $DB_NAME -f {{backup_path}}/{{filename}}

    restore(backup_file: str, !host|H: str = $DB_HOST, !force:bool = false):
        > env: .env
        > env: PGPASSWORD=$DB_PASSWORD
        > desc: Restore database
        > before: echo "ðŸ”„ Restoring database $DB_NAME from {{backup_file}}"
        > after: echo "âœ… Restored database $DB_NAME from {{backup_file}}"
        > if: {{force}} == "false"
        > script: |
            echo "Running restore script without delete database"
            # Ð¨Ð°Ð³ 1: ÐžÑ‡Ð¸ÑÑ‚ÐºÐ° ÑÑ…ÐµÐ¼Ñ‹
            psql \
            -U "$DB_USER" \
            -h "{{host}}" \
            -p "$DB_PORT" \
            -d "$DB_NAME" \
            -c "DO \$\$ 
                DECLARE r RECORD;
                BEGIN
                FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
                    EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
                END LOOP;
                FOR r IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP
                    EXECUTE 'DROP SEQUENCE IF EXISTS ' || quote_ident(r.sequence_name) || ' CASCADE';
                END LOOP;
                FOR r IN (SELECT viewname FROM pg_views WHERE schemaname = 'public') LOOP
                    EXECUTE 'DROP VIEW IF EXISTS ' || quote_ident(r.viewname) || ' CASCADE';
                END LOOP;
                END \$\$;"

            # Ð¨Ð°Ð³ 2: Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¸Ð· SQL Ñ„Ð°Ð¹Ð»Ð°
            psql \
            -U "$DB_USER" \
            -h "{{host}}" \
            -p "$DB_PORT" \
            -d "$DB_NAME" \
            -f {{backup_file}}
        > else:
        > script: |
            # Ð¨Ð°Ð³ 1: Ð—Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¹
            psql \
            -U "$DB_USER" \
            -h "{{host}}" \
            -p "$DB_PORT" \
            -d "postgres" \
            -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$DB_NAME' AND pid <> pg_backend_pid();"

            # Ð¨Ð°Ð³ 2: Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ Ð‘Ð”
            psql \
            -U "$DB_USER" \
            -h "{{host}}" \
            -p "$DB_PORT" \
            -d "postgres" \
            -c "DROP DATABASE IF EXISTS $DB_NAME;"

            # Ð¨Ð°Ð³ 3: Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð‘Ð”
            psql \
            -U "$DB_USER" \
            -h "{{host}}" \
            -p "$DB_PORT" \
            -d "postgres" \
            -c "CREATE DATABASE $DB_NAME;"

            # Ð¨Ð°Ð³ 4: Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¸Ð· SQL Ñ„Ð°Ð¹Ð»Ð°
            psql \
            -U "$DB_USER" \
            -h "{{host}}" \
            -p "$DB_PORT" \
            -d "$DB_NAME" \
            -f {{backup_file}}
                            
    list(!backup_path|p: str = "./backups"):
        > desc: List database backups
        > script: find {{backup_path}} -maxdepth 1 -type f -name "*.sql" -printf '%T@ %TY-%Tm-%Td %TH:%TM | %f\n' | sort -nr | cut -d' ' -f2-

    migrate():
        > desc: Migrations with Aerich (Dev Mode)
        > env: .env
        > if: $DEV == true
        > script: |
            PYTHONPATH=./src uv run aerich migrate 2>/dev/null
        > else:
        > script: |
            echo "Skipping migrations (DEV != true)"
        > fallback: |
            echo "Not found migrations"
        
    upgrade(type: str = "dev"):
        > desc: Upgrade with Aerich
        > cwd: backend
        > env: .env
        > if: {{type}} == dev
        > script: uv run aerich upgrade
        > elif: {{type}} == prod
        > script: uv run aerich upgrade




app(type: str = "dev"):
    > desc: Control Application
    > env: DOCKER_CMD="docker compose"

    logs(*):
        > desc: Logs Application
        > script: $DOCKER_CMD -f {{type}}.yml logs {{*}}

    list:
        > desc: List Application
        > script: $DOCKER_CMD -f {{type}}.yml config --services

    run(!build:bool=true, !include: arr = [] ):
        > desc: Run Application (prod | dev) with build option
        > env: .env
        > script: |
            $DOCKER_CMD -f {{type}}.yml up {{include}} -d $( [ "{{build}}" = "true" ] && echo "--build" ) --force-recreate

    down:
        > desc: Down Services
        > script: $DOCKER_CMD -f {{type}}.yml down 

    exec(app: str, *commands):
        > desc: Execute commands in Container
        > script: | 
            $DOCKER_CMD -f {{type}}.yml exec {{app}} {{*commands}} 